<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Textgrid specification • readtextgrid</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Textgrid specification">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">readtextgrid</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/textgrid-specification.html">Textgrid specification</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/tjmahr/readtextgrid/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Textgrid specification</h1>
                        <h4 data-toc-skip class="author">Tristan
Mahr</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/tjmahr/readtextgrid/blob/master/vignettes/articles/textgrid-specification.Rmd" class="external-link"><code>vignettes/articles/textgrid-specification.Rmd</code></a></small>
      <div class="d-none name"><code>textgrid-specification.Rmd</code></div>
    </div>

    
    
<p><em>This vignette documents the internal parsing logic of the
<strong>readtextgrid</strong> package. It is intended for developers
maintaining the parser or for developers in other languages, not for end
users of the package.</em></p>
<p>In this article, I describe the specification of the
<code>.TextGrid</code> file format used in this package, note how it
differs from the documented specification provided by Praat, and provide
a high-level overview of R code and a C++ translation that can parse
<code>.TextGrid</code> files.</p>
<div class="section level2">
<h2 id="example--textgrid-file-contents">Example <code>.TextGrid</code> file contents<a class="anchor" aria-label="anchor" href="#example--textgrid-file-contents"></a>
</h2>
<p>The <code>.TextGrid</code> file format used by Praat is very
flexible. Below are three different <code>.TextGrid</code> files
representing the same Praat textgrid.</p>
<p>Long format:</p>
<pre><code>File type = "ooTextFile"
Object class = "TextGrid"

xmin = 0 
xmax = 1 
tiers? &lt;exists&gt; 
size = 1 
item []: 
    item [1]:
        class = "IntervalTier" 
        name = "Mary" 
        xmin = 0 
        xmax = 1 
        intervals: size = 1 
        intervals [1]:
            xmin = 0 
            xmax = 1 
            text = "" </code></pre>
<p>Short format:</p>
<pre><code>File type = "ooTextFile"
Object class = "TextGrid"

0
1
&lt;exists&gt;
1
"IntervalTier"
"Mary"
0
1
1
0
1
""</code></pre>
<p>Custom format with comments and other noise:</p>
<pre><code>File type = "ooTextFile"
Object class = "TextGrid"

! info about the grid
0s 1s &lt;exists&gt; 1
! info about the tier
"IntervalTier" "Mary" 0s 1s 1 ! type, name, xmin, xmax, size
0s 1s "" ! interval xmin, xmax, size</code></pre>
<p>readtextgrid can handle all three of these files in the same way
because the Praat textgrid specification is simple—once you figure it
out. I developed the readtextgrid specification by reading Praat’s
description of the format, testing various edge cases in the format and
testing whether Praat would open the test file. If Praat could handle
the file, it had to be supported by this package’s textgrid parser.</p>
</div>
<div class="section level2">
<h2 id="package-design">Package design<a class="anchor" aria-label="anchor" href="#package-design"></a>
</h2>
<p>To read in <code>.TextGrid</code> file, we do the following:</p>
<ul>
<li>read it in with the proper character encoding</li>
<li>tokenize the file contents from a sequence of characters into a list
of Praat strings and Praat numbers</li>
<li>identify the start and end tokens of each textgrid tier</li>
<li>split those tokens up into batches of data and assemble
dataframes</li>
</ul>
<p>This document concerns the tokenization step. The remaining parsing
steps follow straightforward split-apply-combine programming in R.</p>
</div>
<div class="section level2">
<h2 id="documented--textgrid-file-format-specification">Documented <code>.TextGrid</code> file format specification<a class="anchor" aria-label="anchor" href="#documented--textgrid-file-format-specification"></a>
</h2>
<p>First, let’s start with <a href="https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html" class="external-link">Paul
Boersma’s own description</a> of the file format. He notes that the long
format contains several comments to help a person read the file, and
that these are ultimately ignored by Praat. Instead, there are only a
few important tokens:</p>
<blockquote>
<p>Praat will consider as data only the following types of information
in the file:</p>
<ul>
<li>free-standing numbers, such as <code>0</code> and <code>2.3</code>
above, but not <code>[1]</code> or <code>[3]</code>;</li>
<li>free-standing text enclosed within double quotes, such as
<code>"TextGrid"</code> and <code>""</code> above;</li>
<li>free-standing flags, such as <code>&lt;exists&gt;</code> above (this
is the only flag that appears in TextGrid files […]).</li>
</ul>
<p>In this list, “free-standing” means that the number, text or flag is
preceded by the beginning of the file, the beginning of a line, or a
space, and that it is followed by the end of the file, the end of a
line, or a space.</p>
</blockquote>
<p>He also mentions additional features about the format:</p>
<ul>
<li>
<code>!</code> comments: “everything that follows an exclamation
mark on the same line is considered a comment”.</li>
<li>
<code>""</code> escapement by doubling: “a double quote that appears
in a text [<em>i.e.</em>, a string] is written as a <em>doubled</em>
double quote in the text file.”</li>
<li>ignore the <code>&lt;flag&gt;</code> tokens anyway: “The flag
<code>&lt;exists&gt;</code>, which tells us that this TextGrid contains
tiers (this value would be <code>&lt;absent&gt;</code> if the TextGrid
contained no tiers, in which case the file would end here; however, you
cannot really create TextGrid objects without tiers in Praat, so this
issue can be ignored).”</li>
</ul>
<p>These details are mostly accurate and simple enough, but they don’t
specify what to do with <code>.1</code> for example (Praat treat it as
an error).</p>
</div>
<div class="section level2">
<h2 id="our-specification-of-the--textgrid-file-format">Our specification of the <code>.TextGrid</code> file format<a class="anchor" aria-label="anchor" href="#our-specification-of-the--textgrid-file-format"></a>
</h2>
<p>After testing, I developed the following specification for this R
package.</p>
<ul>
<li><p>There are two kinds of tokens: strings and numbers.</p></li>
<li><p><strong>Strings</strong> start and end with a <code>"</code>. If
a string is supposed to have a double-quote character <code>"</code>
inside of it, double the quote characters instead. The textgrid interval
text <em>He said “hello” to me</em> would have the string
<code>"He said ""hello"" to me"</code>. Everything inside of the
<code>"</code> pair belongs to the string, even line breaks and
comments.</p></li>
<li><p>A string is fully “free-standing”. It should be preceded and
followed by a space, newline, or the start or end of a file.
<code>I said"Hello"</code> does not contain a string because there is no
space before the <code>"</code> character.</p></li>
<li><p><strong>Numbers</strong> start with a plus, minus or digit.
Decimal, hexadecimal, and scientific notation are supported. Fractions
are supported. A number ending with a <code>%</code> (a percentage) is
divided by 100. Numbers use a <code>.</code> for the decimal point
character. <code>.5</code> is not a number because it doesn’t start with
a plus, minus or digit.</p></li>
<li><p>A number is “left free-standing” (my terminology). It must be
preceded by a space or newline. (Using the file start doesn’t make sense
for a boundary). From a valid start of a number, characters are read
until the sequence of characters would no longer yield a number. Any
additional characters until the next space, newline, or file boundary
are ignored. In <code>100ms</code> and <code>+100e1ms</code>, for
example, the final <code>ms</code> characters are ignored.</p></li>
<li><p>Praat does not support real numbers with a stranded exponent
(<code>1e</code>). These kinds of numbers are an exception to the
left-free-standing feature described earlier.</p></li>
<li><p>Everything else is a comment and ignored. I differentiate between
two kinds of comments. This is my terminology, not Praat’s.</p></li>
<li><p><strong>“Strong” comments</strong> start with a <code>!</code>
and end with a newline (<code>\n</code>).</p></li>
<li><p><strong>“Weak” comments</strong> would be any token that does not
start like a string or number. In the long format textgrid,
<code>size = 1</code> would be two ignored weak comments
(<code>size</code>, <code>=</code>) and a number
(<code>1</code>).</p></li>
</ul>
<p>The allowance for characters on the right side of numbers is the
major difference between the description of the Praat format and the one
used in this package.</p>
</div>
<div class="section level2">
<h2 id="reference-r-implementation-for-textgrid-tokenization">Reference R implementation for textgrid tokenization<a class="anchor" aria-label="anchor" href="#reference-r-implementation-for-textgrid-tokenization"></a>
</h2>
<p>Given a vector of characters from a Praat <code>.TextGrid</code>
file, we want a list of strings and numbers contained in the file. For
example, here are the characters from the short textgrid file and the
output of the R-based tokenization:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tg_characters</span> <span class="op">&lt;-</span> <span class="va">examples</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/strsplit.html" class="external-link">strsplit</a></span><span class="op">(</span><span class="st">""</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">tg_characters</span></span>
<span><span class="co">#&gt;   [1] "F"  "i"  "l"  "e"  " "  "t"  "y"  "p"  "e"  " "  "="  " "  "\"" "o"  "o" </span></span>
<span><span class="co">#&gt;  [16] "T"  "e"  "x"  "t"  "F"  "i"  "l"  "e"  "\"" "\n" "O"  "b"  "j"  "e"  "c" </span></span>
<span><span class="co">#&gt;  [31] "t"  " "  "c"  "l"  "a"  "s"  "s"  " "  "="  " "  "\"" "T"  "e"  "x"  "t" </span></span>
<span><span class="co">#&gt;  [46] "G"  "r"  "i"  "d"  "\"" "\n" "\n" "0"  "\n" "1"  "\n" "&lt;"  "e"  "x"  "i" </span></span>
<span><span class="co">#&gt;  [61] "s"  "t"  "s"  "&gt;"  "\n" "1"  "\n" "\"" "I"  "n"  "t"  "e"  "r"  "v"  "a" </span></span>
<span><span class="co">#&gt;  [76] "l"  "T"  "i"  "e"  "r"  "\"" "\n" "\"" "M"  "a"  "r"  "y"  "\"" "\n" "0" </span></span>
<span><span class="co">#&gt;  [91] "\n" "1"  "\n" "1"  "\n" "0"  "\n" "1"  "\n" "\"" "\"" "\n"</span></span>
<span></span>
<span><span class="va">tg_characters</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">readtextgrid</span><span class="fu">:::</span><span class="fu">r_tokenize_textgrid_chars</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; List of 13</span></span>
<span><span class="co">#&gt;  $ : chr "ooTextFile"</span></span>
<span><span class="co">#&gt;  $ : chr "TextGrid"</span></span>
<span><span class="co">#&gt;  $ : num 0</span></span>
<span><span class="co">#&gt;  $ : num 1</span></span>
<span><span class="co">#&gt;  $ : num 1</span></span>
<span><span class="co">#&gt;  $ : chr "IntervalTier"</span></span>
<span><span class="co">#&gt;  $ : chr "Mary"</span></span>
<span><span class="co">#&gt;  $ : num 0</span></span>
<span><span class="co">#&gt;  $ : num 1</span></span>
<span><span class="co">#&gt;  $ : num 1</span></span>
<span><span class="co">#&gt;  $ : num 0</span></span>
<span><span class="co">#&gt;  $ : num 1</span></span>
<span><span class="co">#&gt;  $ : chr ""</span></span></code></pre></div>
<p>Some comments about this function:</p>
<ul>
<li>
<code>r_tokenize_textgrid_chars()</code> is not an exported or
supported function. That is why it needs to be accessed with the triple
colon namespace operator <code>:::</code>.</li>
<li>The function was the intended implementation for the package until I
converted the implementation to C++. I keep this R version around as a
reference implementation for testing the current C++
implementation.</li>
<li>Don’t use it.</li>
</ul>
<p>The big ideas in <code>r_tokenize_textgrid_chars()</code> are the
following:</p>
<ul>
<li><p>We have three special states: <code>in_strong_comment</code>,
<code>in_string</code>, and <code>in_escaped_quote</code>. These
determine how we interpret spaces, newlines, and <code>"</code>
characters. When <code>in_strong_comment</code> is true, we skip the
character iteration loop with <code><a href="https://rdrr.io/r/base/Control.html" class="external-link">next</a></code> until we see a newline.
When <code>in_escaped_quote</code> is true, we skip the next iteration
of the loop (to catch next to <code>"</code>). When
<code>in_string</code> is true, we keep collecting characters for the
current token until we see a closing <code>"</code>.</p></li>
<li><p>When these states are all false <em>and</em> we see a space or
newline, then we have the end of current token. We extract the
characters for the current token, combine them into a single value,
check the value and keep it if it is a Praat string or Praat number.
Then we reset the current token position and advance.</p></li>
</ul>
<p>Everything else is book-keeping to check for a special state or
initialize a new token.</p>
<p>The complete code is given below. It is fairly well-commented but you
don’t have to read it—just knowing the high-level details is
sufficient.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw">function</span><span class="op">(</span><span class="va">all_char</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># The parser rules here follow the textgrid specifications</span></span>
<span>  <span class="co"># &lt;https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html&gt; EXCEPT</span></span>
<span>  <span class="co"># when they contradict the behavior of Praat.exe. For example, the specs says</span></span>
<span>  <span class="co"># the main literals are freestanding strings and numbers, where freestanding</span></span>
<span>  <span class="co"># means that they have a whitespace or boundary (newline or file start/end).</span></span>
<span>  <span class="co"># But Praat.exe can handle numbers like "10.00!comment". So, this parser</span></span>
<span>  <span class="co"># gathers freestanding literals but only keeps ones that are strings or</span></span>
<span>  <span class="co"># start with a valid number (the non-numeric characters are lopped off.)</span></span>
<span></span>
<span>  <span class="va">in_strong_comment</span> <span class="op">&lt;-</span> <span class="cn">FALSE</span>         <span class="co"># Comment mode: ! to new line \n</span></span>
<span>  <span class="va">in_string</span> <span class="op">&lt;-</span> <span class="cn">FALSE</span>                 <span class="co"># String mode: "Quote to quote"</span></span>
<span>  <span class="va">in_escaped_quote</span> <span class="op">&lt;-</span> <span class="cn">FALSE</span>          <span class="co"># Escaped quote: "" inside of a string</span></span>
<span></span>
<span>  <span class="va">token_start</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/integer.html" class="external-link">integer</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span>          <span class="co"># Start of current token</span></span>
<span>  <span class="va">values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">vector</a></span><span class="op">(</span>mode <span class="op">=</span> <span class="st">"list"</span><span class="op">)</span>    <span class="co"># Collects completed values</span></span>
<span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">all_char</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">cur_value_ready</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">token_start</span><span class="op">)</span> <span class="op">!=</span> <span class="fl">0</span></span>
<span>    <span class="va">c</span> <span class="op">&lt;-</span> <span class="va">all_char</span><span class="op">[</span><span class="va">i</span><span class="op">]</span></span>
<span>    <span class="va">c_is_whitespace</span> <span class="op">&lt;-</span> <span class="va">c</span> <span class="op"><a href="https://rdrr.io/r/base/match.html" class="external-link">%in%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">" "</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span>    <span class="va">c_starts_string</span> <span class="op">&lt;-</span> <span class="va">c</span> <span class="op">==</span> <span class="st">"\""</span></span>
<span></span>
<span>    <span class="co"># Comments start with ! and end with \n. Skip characters in this mode.</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="va">in_string</span> <span class="op">&amp;</span> <span class="va">c</span> <span class="op">==</span> <span class="st">"!"</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">in_strong_comment</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span></span>
<span>      <span class="kw">next</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">in_strong_comment</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="kw">if</span> <span class="op">(</span><span class="va">c</span> <span class="op">==</span> <span class="st">"\n"</span><span class="op">)</span> <span class="va">in_strong_comment</span> <span class="op">&lt;-</span> <span class="cn">FALSE</span></span>
<span>      <span class="kw">next</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="co"># Whitespace delimits values so collect values if we see whitespace</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">c_is_whitespace</span> <span class="op">&amp;</span> <span class="op">!</span><span class="va">in_string</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="co"># Skip whitespace if no values collected so far</span></span>
<span>      <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="va">cur_value_ready</span><span class="op">)</span> <span class="kw">next</span></span>
<span></span>
<span>      <span class="va">total_value</span> <span class="op">&lt;-</span> <span class="va">all_char</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="va">token_start</span>, <span class="va">i</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span>collapse <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span>
<span>      <span class="va">is_string</span> <span class="op">&lt;-</span> <span class="va">all_char</span><span class="op">[</span><span class="va">token_start</span><span class="op">]</span> <span class="op">==</span> <span class="st">"\""</span> <span class="op">&amp;&amp;</span> <span class="va">all_char</span><span class="op">[</span><span class="va">i</span> <span class="op">-</span> <span class="fl">1</span><span class="op">]</span> <span class="op">==</span> <span class="st">"\""</span></span>
<span></span>
<span>      <span class="co"># Collect only numbers and strings</span></span>
<span>      <span class="kw">if</span> <span class="op">(</span><span class="fu">r_tg_parse_is_number</span><span class="op">(</span><span class="va">total_value</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>        <span class="co"># Keep only the numeric part.</span></span>
<span>        <span class="va">total_value</span> <span class="op">&lt;-</span> <span class="va">total_value</span> <span class="op">|&gt;</span> <span class="fu">r_tg_parse_extract_number</span><span class="op">(</span><span class="op">)</span></span>
<span>        <span class="va">values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">values</span>, <span class="va">total_value</span><span class="op">)</span></span>
<span>      <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">is_string</span><span class="op">)</span> <span class="op">{</span></span>
<span>        <span class="va">values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">values</span>, <span class="va">total_value</span><span class="op">)</span></span>
<span>      <span class="op">}</span></span>
<span>      <span class="va">token_start</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/integer.html" class="external-link">integer</a></span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span>
<span>      <span class="kw">next</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="co"># Store character if ending an escaped quote</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">in_escaped_quote</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">in_escaped_quote</span> <span class="op">&lt;-</span> <span class="op">!</span><span class="va">in_escaped_quote</span></span>
<span>      <span class="kw">next</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="co"># Start or close string mode if we see "</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">c_starts_string</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="co"># Check for "" escapes</span></span>
<span>      <span class="va">peek_c</span> <span class="op">&lt;-</span> <span class="va">all_char</span><span class="op">[</span><span class="va">i</span> <span class="op">+</span> <span class="fl">1</span><span class="op">]</span></span>
<span>      <span class="kw">if</span> <span class="op">(</span><span class="va">peek_c</span> <span class="op">==</span> <span class="st">"\""</span> <span class="op">&amp;</span> <span class="va">in_string</span><span class="op">)</span> <span class="op">{</span></span>
<span>        <span class="va">in_escaped_quote</span> <span class="op">&lt;-</span> <span class="cn">TRUE</span></span>
<span>      <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>        <span class="va">in_string</span> <span class="op">&lt;-</span> <span class="op">!</span><span class="va">in_string</span></span>
<span>      <span class="op">}</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="va">cur_value_ready</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">token_start</span> <span class="op">&lt;-</span> <span class="va">i</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span></span>
<span>  <span class="va">values</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">r_tg_parse_convert_value</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="c-implementation">C++ implementation<a class="anchor" aria-label="anchor" href="#c-implementation"></a>
</h2>
<p>Given the simple nature of the R code and its relatively slow
performance compared to the legacy version of the parser, I used ChatGPT
to help convert the R code into a C++ implementation built on the cpp11
package. I tried to make sure I understood every line and made my own
comments to help my understanding.</p>
<p>The C++ code is a straightforward translation of the R version. For
example, here is the part of the function that collects tokens when we
see a space or newline:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>in_string <span class="op">&amp;&amp;</span> is_ws<span class="op">(</span>b<span class="op">))</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>have_token<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>        <span class="dt">size_t</span> start <span class="op">=</span> tok_start_byte<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>        <span class="dt">size_t</span> end   <span class="op">=</span> <span class="op">(</span>curr_char_byte <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> prev_char_byte<span class="op">);</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>        <span class="dt">size_t</span> len   <span class="op">=</span> <span class="op">(</span>end <span class="op">&gt;=</span> start<span class="op">)</span> <span class="op">?</span> <span class="op">(</span>end <span class="op">-</span> start <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>len <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>          <span class="co">// do we have a string (start and end with ")</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>          <span class="dt">bool</span> q <span class="op">=</span> <span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">&gt;(</span>src<span class="op">[</span>start<span class="op">])</span> <span class="op">==</span> <span class="bn">0x22</span><span class="op">)</span> <span class="op">&amp;&amp;</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>            <span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">unsigned</span> <span class="dt">char</span><span class="op">&gt;(</span>src<span class="op">[</span>end<span class="op">])</span>   <span class="op">==</span> <span class="bn">0x22</span><span class="op">);</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>          tokens<span class="op">.</span>push_back<span class="op">(</span>src<span class="op">.</span>substr<span class="op">(</span>start<span class="op">,</span> len<span class="op">));</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>          tokens_is_string<span class="op">.</span>push_back<span class="op">(</span>q<span class="op">);</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>        have_token <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>      <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Some details are different: The C++ version extracts tokens with a
substring (<code>.substr()</code>) method, delays checking whether the
token is a number until later on, and accumulates results into lists
(<code>tokens</code> and <code>tokens_is_string</code>). But the
underlying logic is the same as the R version.</p>
<p>The C++ function takes a single character value (one whole string)
for the file contents and returns a list of the tokens in the file,
whether each token is a Praat string, the numbers of characters of each
token that form a number, and the value of that token’s number:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">examples</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu">readtextgrid</span><span class="fu">:::</span><span class="fu">cpp_tg_scan_tokens</span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt;            tokens is_string num_prefix num_value</span></span>
<span><span class="co">#&gt; 1            File     FALSE          0        NA</span></span>
<span><span class="co">#&gt; 2            type     FALSE          0        NA</span></span>
<span><span class="co">#&gt; 3               =     FALSE          0        NA</span></span>
<span><span class="co">#&gt; 4    "ooTextFile"      TRUE          0        NA</span></span>
<span><span class="co">#&gt; 5          Object     FALSE          0        NA</span></span>
<span><span class="co">#&gt; 6           class     FALSE          0        NA</span></span>
<span><span class="co">#&gt; 7               =     FALSE          0        NA</span></span>
<span><span class="co">#&gt; 8      "TextGrid"      TRUE          0        NA</span></span>
<span><span class="co">#&gt; 9               0     FALSE          1         0</span></span>
<span><span class="co">#&gt; 10              1     FALSE          1         1</span></span>
<span><span class="co">#&gt; 11       &lt;exists&gt;     FALSE          0        NA</span></span>
<span><span class="co">#&gt; 12              1     FALSE          1         1</span></span>
<span><span class="co">#&gt; 13 "IntervalTier"      TRUE          0        NA</span></span>
<span><span class="co">#&gt; 14         "Mary"      TRUE          0        NA</span></span>
<span><span class="co">#&gt; 15              0     FALSE          1         0</span></span>
<span><span class="co">#&gt; 16              1     FALSE          1         1</span></span>
<span><span class="co">#&gt; 17              1     FALSE          1         1</span></span>
<span><span class="co">#&gt; 18              0     FALSE          1         0</span></span>
<span><span class="co">#&gt; 19              1     FALSE          1         1</span></span>
<span><span class="co">#&gt; 20             ""      TRUE          0        NA</span></span></code></pre></div>
<p>Before I had figured out how to parse numbers with C++, I originally
was going to use R code on the <code>token</code> column to figure out
whether each token is a legal number or not. That’s why this function
returns a list of vectors with information about the tokens.</p>
<p>Back in the R layer, the final tokens are selected using really basic
vector operations:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">readtextgrid</span><span class="fu">:::</span><span class="va">tokenize_textgrid</span></span>
<span><span class="co">#&gt; function (tg_text) </span></span>
<span><span class="co">#&gt; {</span></span>
<span><span class="co">#&gt;     res &lt;- withr::with_locale(c(LC_NUMERIC = "C"), cpp_tg_scan_tokens(tg_text))</span></span>
<span><span class="co">#&gt;     toks &lt;- res$tokens</span></span>
<span><span class="co">#&gt;     is_string &lt;- res$is_string</span></span>
<span><span class="co">#&gt;     is_number &lt;- (res$num_prefix != 0) &amp; !is_string</span></span>
<span><span class="co">#&gt;     keep &lt;- is_number | is_string</span></span>
<span><span class="co">#&gt;     toks &lt;- toks[keep]</span></span>
<span><span class="co">#&gt;     out &lt;- vector("list", length(toks))</span></span>
<span><span class="co">#&gt;     strings &lt;- toks[is_string[keep]]</span></span>
<span><span class="co">#&gt;     strings &lt;- substring(strings, 2L, nchar(strings) - 1L)</span></span>
<span><span class="co">#&gt;     strings &lt;- gsub("\"\"", "\"", strings, fixed = TRUE)</span></span>
<span><span class="co">#&gt;     out[is_string[keep]] &lt;- strings</span></span>
<span><span class="co">#&gt;     out[is_number[keep]] &lt;- res$num_value[is_number]</span></span>
<span><span class="co">#&gt;     out</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="co">#&gt; &lt;bytecode: 0x55d68b30c6e8&gt;</span></span>
<span><span class="co">#&gt; &lt;environment: namespace:readtextgrid&gt;</span></span></code></pre></div>
<p>An important part of this function is the
<code>withr::with_locale(c(LC_NUMERIC = "C"), ... )</code> call. We are
setting the locale for numbers to the C locale which means that
<code>.</code> is the decimal point character, and not a comma as in
some locales.</p>
<p>Parsing numbers is also handled by C++. I discovered that the
standard library <code>strtod()</code> function does exactly what we
need:</p>
<blockquote>
<p>Interprets a floating-point value in a byte string pointed to by
<code>str</code>.</p>
<p>Function discards any whitespace characters (as determined by
<code>isspace</code>) until first non-whitespace character is found.
Then it takes as many characters as possible to form a valid
floating-point representation and converts them to a floating-point
value.</p>
<p>– <a href="https://en.cppreference.com/w/c/string/byte/strtof" class="external-link uri">https://en.cppreference.com/w/c/string/byte/strtof</a></p>
</blockquote>
<p>We include some additional logic to make sure that <code>.4</code> is
illegal and to output <code>NA_real_</code> for missing values, but
otherwise, <code>strtod()</code> does the work for us.</p>
<p>One consequence of this approach is that we can parse other kinds of
numbers like hexadecimal with exponents. It turns out that Praat can
also parse these numbers in a <code>.TextGrid</code> file as well.</p>
<p>The number-parsing logic has its own function, so we can test how
tokens specific tokens are parsed:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test_nums</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"+1.0"</span>, <span class="st">"000ms"</span>, <span class="st">"-2"</span>, <span class="st">"0xA"</span>, <span class="st">".5"</span>, <span class="st">"+.0"</span><span class="op">)</span> </span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>  test_nums <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">test_nums</span><span class="op">)</span>,</span>
<span>  <span class="fu">readtextgrid</span><span class="fu">:::</span><span class="fu">cpp_parse_praat_numbers</span><span class="op">(</span><span class="va">test_nums</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;   test_nums prefix_len value</span></span>
<span><span class="co">#&gt; 1      +1.0          4     1</span></span>
<span><span class="co">#&gt; 2     000ms          3     0</span></span>
<span><span class="co">#&gt; 3        -2          2    -2</span></span>
<span><span class="co">#&gt; 4       0xA          3    10</span></span>
<span><span class="co">#&gt; 5        .5          0    NA</span></span>
<span><span class="co">#&gt; 6       +.0          0    NA</span></span></code></pre></div>
<p>There are two limitations with the number parser used in this
package:</p>
<ul>
<li>We do not support fractions and percentages. (Praat does.)</li>
<li>We accept stranded exponents. (Praat does not.)</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test_nums</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"1e"</span>, <span class="st">"1E"</span>, <span class="st">"20/10"</span>, <span class="st">"1000%"</span><span class="op">)</span> </span>
<span><span class="va">expected</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="cn">NA_real_</span>, <span class="cn">NA_real_</span>, <span class="fl">2.0</span>, <span class="fl">10.0</span><span class="op">)</span> </span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>  test_nums <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">test_nums</span><span class="op">)</span>,</span>
<span>  <span class="fu">readtextgrid</span><span class="fu">:::</span><span class="fu">cpp_parse_praat_numbers</span><span class="op">(</span><span class="va">test_nums</span><span class="op">)</span>,</span>
<span>  expected_value <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">expected</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;   test_nums prefix_len value expected_value</span></span>
<span><span class="co">#&gt; 1        1e          1     1             NA</span></span>
<span><span class="co">#&gt; 2        1E          1     1             NA</span></span>
<span><span class="co">#&gt; 3     20/10          2    20              2</span></span>
<span><span class="co">#&gt; 4     1000%          4  1000             10</span></span></code></pre></div>
<p>These are not high-priority limitations until we find a case where a
software program writes out <code>.TextGrid</code> files that uses these
features.</p>
</div>
<div class="section level2">
<h2 id="notes-on-testing">Notes on testing<a class="anchor" aria-label="anchor" href="#notes-on-testing"></a>
</h2>
<p>The package’s folder <code>tests/testthat/test-data</code> includes a
series of <code>.TextGrid</code> files for testing the parsing
functions. One of these, <code>hard-to-parse.TextGrid</code>, collects
as many edge cases as I can imagine.</p>
<p>The C++ implementation is tested against the legacy parser on easy
long-format textgrid files and against the pure R implementation on
other test textgrid files, including
<code>hard-to-parse.TextGrid</code>.</p>
<p>The folder <code>tests/testthat/test-data/praat-test</code> include
some tests of whether Praat can open a file or not. Files that fail to
open start with <code>fail-</code> and files that open start with
<code>okay-</code>. We support the only the syntactic features in the
<code>okay-</code> files.</p>
</div>
<div class="section level2">
<h2 id="notes-on-the-praat-source-code">Notes on the Praat source code<a class="anchor" aria-label="anchor" href="#notes-on-the-praat-source-code"></a>
</h2>
<p>I did not rely on the Praat source code but I tried! The Praat source
code has to read in all kinds of text files so there is not an obvious
<code><a href="../reference/read_textgrid.html">read_textgrid()</a></code>-like function for parsing a
<code>.TextGrid</code> file. Still, I was able to find how numbers a
read in from a text file.</p>
<p>The primitive data types of Praat are defined in the
<code>Melder</code> folder. The <code>abcio.cpp</code> files has
functions like <code>getReal()</code> for reading a float from text.
<code>getReal()</code> calls <code>Melder_a8tof()</code> function in
<code>melder_atof.cpp</code> to convert strings into numbers, and this
function in turn calls <code>findEndOfNumericString()</code> which
processes numbers character by character.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Tristan Mahr, Josef Fruehwald.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
