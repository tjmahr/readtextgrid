---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# readtextgrid <img src="man/figures/logo.png" width = "150" align="right" />

<!-- badges: start -->
[![CRAN status](https://www.r-pkg.org/badges/version/readtextgrid)](https://CRAN.R-project.org/package=readtextgrid)
[![readtextgrid status badge](https://tjmahr.r-universe.dev/readtextgrid/badges/version)](https://tjmahr.r-universe.dev/readtextgrid)
[![R-CMD-check](https://github.com/tjmahr/readtextgrid/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/tjmahr/readtextgrid/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

readtextgrid parses Praat textgrids into R dataframes.

## Installation

Install from CRAN:

``` r 
install.packages("readtextgrid")
```

Install the development version from R-universe:

``` r
install.packages(
  "readtextgrid", 
  repos = c("https://tjmahr.r-universe.dev", "https://cloud.r-project.org")
)
```

## Basic example

Here is the example textgrid created by Praat. It was created using 
`New -> Create TextGrid...` with default settings in Praat.

<img src="man/figures/demo-textgrid.png" width="600" /> 

This textgrid is bundled with this R package. We can locate the file with
`example_textgrid()`. We read in the textgrid with `read_textgrid()`.

```{r example, R.options = list(tibble.width = 100)}
library(readtextgrid)

# Locates path to an example textgrid bundled with this package
tg <- example_textgrid()

read_textgrid(path = tg)
```

The dataframe contains one row per annotation: one row for each interval on an
interval tier and one row for each point on a point tier. If a point tier has no
points, it is represented with single row with `NA` values.

The columns encode the following information:

  - `file` filename of the textgrid. By default this column uses the filename in
    `path`. A user can override this value by setting the `file` argument in
    `read_textgrid(path, file)`, which can be useful if textgrids are stored in
    speaker-specific folders.
  - `tier_num` the number of the tier (as in the left margin of the textgrid
    editor)
  - `tier_name` the name of the tier (as in the right margin of the textgrid
    editor)
  - `tier_type` the type of the tier. `"IntervalTier"` for interval tiers and
    `"TextTier"` for point tiers (this is the terminology used inside of the
    textgrid file format).
  - `tier_xmin`, `tier_xmax` start and end times of the tier in seconds
  - `xmin`, `xmax` start and end times of the textgrid interval or point tier
    annotation in seconds
  - `text` the text in the annotation
  - `annotation_num` the number of the annotation in that tier (1 for the first
    annotation, etc.)

## Reading in directories of textgrids

Suppose you have data on multiple speakers with one folder of textgrids per
speaker. As an example, this package has a folder called `speaker_data` bundled
with it representing 5 five textgrids from 2 speakers.

```
speaker-data
+-- speaker001
|   +-- s2T01.TextGrid
|   +-- s2T02.TextGrid
|   +-- s2T03.TextGrid
|   +-- s2T04.TextGrid
|   \-- s2T05.TextGrid
\-- speaker002
    +-- s2T01.TextGrid
    +-- s2T02.TextGrid
    +-- s2T03.TextGrid
    +-- s2T04.TextGrid
    \-- s2T05.TextGrid
```

First, we create a vector of file-paths to read into R.

```{r}
# Get the path of the folder bundled with the package
data_dir <- system.file(package = "readtextgrid", "speaker-data")

# Get the full paths to all the textgrids
paths <- list.files(
  path = data_dir, 
  pattern = "TextGrid$",
  full.names = TRUE, 
  recursive = TRUE
)
```

We can use `purrr::map_dfr()`--*map* the `read_textgrid` function over the
`paths` and combine the dataframes (`_dfr`)---to read all these textgrids into
R. But note that this way loses the speaker information.

```{r, R.options = list(tibble.width = 100)}
library(purrr)

map_dfr(paths, read_textgrid)
```

We can use `purrr::map2_dfr()` and some dataframe manipulation to add the
speaker information. 

```{r, R.options = list(tibble.width = 100), message = FALSE, warning = FALSE}
library(dplyr)

# This tells read_textgrid() to set the file column to the full path
data <- map2_dfr(paths, paths, read_textgrid) |> 
  mutate(
    # basename() removes the folder part from a path, 
    # dirname() removes the file part from a path
    speaker = basename(dirname(file)),
    file = basename(file),
  ) |> 
  select(
    speaker, everything()
  )

data
```

Another strategy would be to read the textgrid dataframes into a list column and
`unnest()` them.

```{r}
# Read dataframes into a list column
data_nested <- tibble(
  speaker = basename(dirname(paths)),
  data = map(paths, read_textgrid)
)

# We have one row per textgrid dataframe because `data` is a list column
data_nested

# promote the nested dataframes into the main dataframe
tidyr::unnest(data_nested, "data")
```

## Pivoting textgrids

In the textgrids above, there is a natural nesting or hierarchy to the tiers.
Intervals in `words` tier contain intervals in the `phones` tier. It is often
necessary to group intervals by their parent intervals (group phones by words).
This package provides the `pivot_textgrid_tiers()` function to convert textgrids
into a wide format in a way that respect the nesting/hierarchy of tiers.

```{r}
data_wide <- pivot_textgrid_tiers(
  data, 
  tiers = c("words", "phones"), 
  join_cols = c("speaker", "file")
)

data_wide

# more clearly,
data_wide |> 
  select(
    speaker, file, words, phones, 
    words_xmin, words_xmax, phones_xmin, phones_xmax
  )
```

Some remarks:

  - Each tier in `tiers` becomes a batch of columns. For the rows for the
    `words` tier become the batch of columns `words` (the original `text`
    value), `words_xmin`, `words_xmax`, etc.
  - The columns in `join_cols` should uniquely identify a textgrid file, so the
    combination of `speaker` and `file` is needed in the case where different
    speakers have the same file.
  - The tier names in `tiers` should be given in the order of their nesting from
    outside to inside (e.g., `words` contain `phones`). Behind the scenes,
    `dplyr::left_join(..., relationship = "one-to-many")` is used to constrain
    how intervals are combined. 

This function also works on a single `tiers` value. In this case, the function
returns just the intervals in that tier with the columns renamed and prefixed.

```{r}
data |> 
  pivot_textgrid_tiers(
    tiers = "words", 
    join_cols = c("speaker", "file")
  )
```


## Other tips

### Speeding things up

Do you have thousands of textgrids to read? The following workflow can speed
things up. We are going to **read the textgrids in parallel**. Below are two 
approaches:

- future backend and furrr frontend
- mirai backend and purrr frontend

The backend manages the parallel computation, and the frontend provides the 
syntax for calling a function with parallelism. 

Approach 1: We tell future to use a `multisession` `plan` for parallelism,
so the computations are done on separate R sessions in the background. The
syntax is like the above purrr code, but we replace `map()` with `future_map()`.

```{r, warning = FALSE}
library(future)
library(furrr)
plan(multisession, workers = 4)

data_nested <- tibble(
  speaker = basename(dirname(paths)),
  data = future_map(paths, read_textgrid)
)
```

Approach 2: We have mirai set up 4 daemons (background processes), and then we
use purrr's `in_parallel()` helper to signal to `map()` that the function should
be run in parallel. We need to give all the information needed for the daemons
to run the function, so we 1) provide a complete function definition
(`function(x) ...`) and 2) spell out the package namespace
`readtextgrid::read_textgrid()`.

```{r, warning = FALSE}
mirai::daemons(4)
data_nested <- tibble(
  speaker = basename(dirname(paths)),
  data = map(paths, in_parallel(function(x) readtextgrid::read_textgrid(x)))
)
mirai::daemons(0)
```

Another way to eke out performance is to set the encoding. By default,
readtextgrid uses `readr::guess_encoding()` to determine the encoding of the
textgrid before reading it in. But if you know the encoding beforehand, you can
skip this guessing. In my limited testing, I found that **setting the encoding**
could reduce benchmark times by 3--4% compared to guessing the encoding.

Here, we read 100 textgrids using different approaches to benchmark the 
results. 

```{r}
paths_bench <- withr::with_seed(1, sample(paths, 100, replace = TRUE))

mirai::daemons(4)
bench::mark(
  lapply_guess = lapply(paths_bench, read_textgrid),
  lapply_set = lapply(paths_bench, read_textgrid, encoding = "UTF-8"),
  future_guess = future_map(paths_bench, read_textgrid),
  future_set = future_map(paths_bench, read_textgrid, encoding = "UTF-8"), 
  mirai_guess = purrr::map(
    paths_bench, 
    in_parallel(function(x) readtextgrid::read_textgrid(x))
  ),
  mirai_set = purrr::map(
    paths_bench, 
    in_parallel(function(x) readtextgrid::read_textgrid(x, encoding = "UTF-8"))
  ),
  check = TRUE
)

mirai::daemons(0)
```

### Legacy behavior

```{r, include = FALSE}
examples <- c(
'File type = "ooTextFile"
Object class = "TextGrid"

xmin = 0 
xmax = 1 
tiers? <exists> 
size = 1 
item []: 
    item [1]:
        class = "IntervalTier" 
        name = "Mary" 
        xmin = 0 
        xmax = 1 
        intervals: size = 1 
        intervals [1]:
            xmin = 0 
            xmax = 1 
            text = "" 
',

'File type = "ooTextFile"
Object class = "TextGrid"

0
1
<exists>
1
"IntervalTier"
"Mary"
0
1
1
0
1
""
',
'File type = "ooTextFile"
Object class = "TextGrid"

! info about the grid
0s 1s <exists> 1
! info about the tier
"IntervalTier" "Mary" 0s 1s 1 ! type, name, xmin, xmax, size
0s 1s "" ! interval xmin, xmax, size
'
)
# make sure these don't actually error
example_tgs <- lapply(examples, read_textgrid_lines)
```


The original version of this package assumed textgrids followed a long format
with helpful labels and annotations. For example, in the following textgrid,
each number here has a label that makes it easy and fast to parse the textgrid
with regular expressions:

```{r, echo = FALSE, comment = ""}
writeLines(examples[1])
```

The original version of the parser designed for this textgrid format is still
provided with the `legacy_read_textgrid()` and `legacy_read_textgrid_lines()`
functions.

Version 2.0.0 of readtextgrid added a C++ based parser that can handle many more
textgrid formats. For example, it can short format textgrids like the following:

```{r, echo = FALSE, comment = ""}
writeLines(examples[2])
```

And it can handle more [esoteric
features](https://www.fon.hum.uva.nl/praat/manual/TextGrid_file_formats.html)
like comments (that start with `!`) or arbitrary text attached to a number (all
of the times have `s` after them.)

```{r, echo = FALSE, comment = ""}
writeLines(examples[3])
```

Because the new parser uses C++ for tokenization---that is, the part scans the
contents character by character and determines whether the inputs are strings,
numbers, or skipped---it is much faster the legacy version.

```{r}
paths_bench <- withr::with_seed(2, sample(paths, 10, replace = TRUE))

bench::mark(
  current = lapply(paths_bench, read_textgrid),
  legacy = lapply(paths_bench, legacy_read_textgrid),
  min_iterations = 10, 
  filter_gc = FALSE,
  check = TRUE
)
```


### Helpful columns

The following columns are often helpful:

- `duration` of an interval
- `xmid` midpoint of an interval
- `total_annotations` total number of annotations on a tier

Here is how to create them:

```{r}
data |>
  # grouping needed for counting annotations per tier per file per speaker
  group_by(speaker, file, tier_num) |>
  mutate(
    duration = xmax - xmin,
    xmid = xmin + (xmax - xmin) / 2,
    total_annotations = sum(!is.na(annotation_num))
  ) |> 
  ungroup() |> 
  glimpse()
```


### Launching Praat

*This tip is written from the perspective of a Windows user who uses git bash
for a terminal*. 

To open textgrids in Praat, you can tell R to call Praat from
the command line. You have to know where the location of the Praat binary is
though. I like to keep a copy in my project directories. So, assuming that
Praat.exe in my working folder, the following would open the 10 textgrids in
`paths` in Praat.

```{r, eval = FALSE}
system2(
  command = "./Praat.exe",
  args = c("--open", paths),
  wait = FALSE
)
```


## Acknowledgments

readtextgrid was created to process data from the [WISC Lab
project](https://kidspeech.wisc.edu/). Thus, development of this package was
supported by NIH R01DC009411 and NIH R01DC015653.

***

Please note that the 'readtextgrid' project is released with a
[Contributor Code of Conduct](https://www.contributor-covenant.org/version/1/0/0/code-of-conduct.html).
By contributing to this project, you agree to abide by its terms.
